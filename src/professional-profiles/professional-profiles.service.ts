import { ForbiddenException, Injectable, Logger } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Response } from 'express';
import * as fs from 'fs/promises';
import * as pdf from 'html-pdf';
import { FilterQuery, Model } from 'mongoose';
import * as path from 'path';
import { EntityStatus } from 'src/shared/enums/status.enum';
import { UserDocument } from 'src/users/schemas/user.schema';
import { PaginatedResponseDto } from '../shared/dto/paginated-response.dto';
import { PaginationParams } from '../shared/dto/pagination-params.dto';
import {
  arrayToHtmlArticleList,
  stringToDate,
  stringToHtmlAnchor,
  titleCase,
} from '../shared/util';
import { TechnologiesService } from '../technologies/technologies.service';
import { ProfessionalProfileGenerator } from './algorithm/main';
import { GetProfessionalProfilesQuery } from './dto/get-professional-profiles-query.dto';
import { TechType } from './enums/tech-type.enum';
import {
  ProfessionalProfile,
  ProfessionalProfileDocument,
} from './schemas/professional-profile.schema';

@Injectable()
export class ProfessionalProfilesService {
  private readonly logger = new Logger(ProfessionalProfilesService.name);

  constructor(
    @InjectModel(ProfessionalProfile.name)
    private readonly proProfileModel: Model<ProfessionalProfileDocument>,
    private readonly generateProfessionalProfile: ProfessionalProfileGenerator,
    private readonly technologiesService: TechnologiesService,
  ) {}

  /**
   * Genera un perfil profesional utilizando un algoritmo que hace Web Scraping.
   * El perfil generado se persiste en la base de datos.
   * @param user - current user
   * @param jobTitle
   * @param location
   */
  async generateProfile(
    user: UserDocument,
    jobTitle: string,
    location: string,
  ): Promise<ProfessionalProfile> {
    const generatedProfile = await this.generateProfessionalProfile.generate(
      user,
      jobTitle,
      location,
    );
    const createdProfile = await this.proProfileModel.create(generatedProfile);
    this.logger.log(
      `Professional profile generated by user ${user.userId}`,
      createdProfile,
    );
    return createdProfile;
  }

  async findActiveProfilesOfUser(
    user: UserDocument,
    getQuery?: GetProfessionalProfilesQuery & PaginationParams,
  ): Promise<PaginatedResponseDto<ProfessionalProfile>> {
    const filterQuery: FilterQuery<ProfessionalProfileDocument> = {
      owner: user._id,
      status: EntityStatus.Active,
    };
    const { initDate, endDate, jobTitle, location, page, size } =
      getQuery || {};
    if (initDate || endDate) filterQuery.createdAt = {};
    if (initDate) filterQuery.createdAt['$gte'] = stringToDate(initDate);
    if (endDate) filterQuery.createdAt['$lt'] = stringToDate(endDate);
    if (jobTitle)
      filterQuery.jobTitle = {
        $regex: new RegExp(jobTitle.trim().replace('.', '')),
        $options: 'i',
      };
    if (location)
      filterQuery.location = {
        $regex: new RegExp(location.trim().replace('.', '')),
        $options: 'i',
      };

    const profiles = await this.proProfileModel
      .find(filterQuery)
      .sort({ createdAt: -1 })
      .skip((page - 1) * size)
      .limit(size)
      .lean();
    const totalItems = await this.proProfileModel.count(filterQuery);
    const totalPages = Math.ceil(totalItems / size);

    this.logger.log(`Professional profiles obtained by user ${user.userId}`);

    return {
      totalItems,
      currentPage: page,
      pageSize: size,
      data: profiles,
      totalPages,
    };
  }

  async findActiveProfileOfUserById(
    ppId: string,
    user: UserDocument,
  ): Promise<ProfessionalProfile> {
    const profile = await this.proProfileModel
      .findOne({ ppId, status: EntityStatus.Active })
      .populate('jobsAnalyzed')
      .lean();
    if (user._id.equals(profile.owner)) {
      return profile;
    }
    throw new ForbiddenException(
      'This profile is not generated by the user who requested it',
    );
  }

  async removeProfileOfUser(user: UserDocument, ppId: string): Promise<void> {
    const profile = await this.proProfileModel.findOne({
      ppId,
      status: EntityStatus.Active,
    });
    if (user._id.equals(profile.owner)) {
      profile.status = EntityStatus.Inactive;
      await profile.save();
      this.logger.log(`Professional profile deleted by user ${user.userId}`);
      return;
    }
    throw new ForbiddenException(
      'This profile is not generated by the user who requested it',
    );
  }

  async getRandomProfile(): Promise<ProfessionalProfile> {
    const profilesCount = await this.proProfileModel.count().exec();
    const random = Math.floor(Math.random() * profilesCount);
    const profile = await this.proProfileModel.findOne().skip(random).exec();
    this.logger.log(`Random professional profile obtained`);
    return profile;
  }

  async getTechnologyCount(profiles: ProfessionalProfile[], type: TechType) {
    const technologies = await this.technologiesService.findByType(type);
    const dictionary: Record<string, number> = {};

    for (const { name } of technologies) {
      switch (type) {
        case TechType.Language:
          dictionary[name] = profiles.filter((profile) =>
            profile.languages.includes(name),
          ).length;
          break;
        case TechType.Database:
          dictionary[name] = profiles.filter((profile) =>
            profile.databases.includes(name),
          ).length;
          break;
        case TechType.Framework:
          dictionary[name] = profiles.filter((profile) =>
            profile.frameworks.includes(name),
          ).length;
          break;
        case TechType.Library:
          dictionary[name] = profiles.filter((profile) =>
            profile.libraries.includes(name),
          ).length;
          break;
        case TechType.Paradigm:
          dictionary[name] = profiles.filter((profile) =>
            profile.paradigms.includes(name),
          ).length;
          break;
        case TechType.Pattern:
          dictionary[name] = profiles.filter((profile) =>
            profile.patterns.includes(name),
          ).length;
          break;
        case TechType.Tool:
          dictionary[name] = profiles.filter((profile) =>
            profile.tools.includes(name),
          ).length;
          break;
      }
    }

    return dictionary;
  }

  async getEnglishCount(profiles: ProfessionalProfile[]) {
    const englishCount = { Yes: 0, No: 0 };

    profiles.forEach((profile) => {
      if (profile.requireEnglish) {
        englishCount.Yes++;
      } else {
        englishCount.No++;
      }
    });

    return englishCount;
  }

  async download(res: Response, user: UserDocument, ppId: string) {
    const templatePath = path.join(__dirname, '../../templates/resume.html');
    let templateHtml = await fs.readFile(templatePath, 'utf8');
    const profile = await this.proProfileModel
      .findOne({ user: user._id, ppId })
      .lean();
    if (!profile)
      return res.status(404).json({
        statusCode: 404,
        message: 'Requested profile not found',
        error: 'Not found',
      });

    // user data
    const name = titleCase(user.name);
    const surname = titleCase(user.surname);
    const biography = titleCase(user.biography);
    const linkedIn = user.linkedIn
      ? stringToHtmlAnchor(user.linkedIn, 'LinkedIn')
      : '';
    const github = user.github ? stringToHtmlAnchor(user.github, 'GitHub') : '';
    const portfolio = user.portfolio
      ? stringToHtmlAnchor(user.portfolio, 'Portafolio')
      : '';

    // profile data
    const jobTitle = profile.jobTitle;
    const languages = arrayToHtmlArticleList(profile.languages, 'Lenguajes');
    const frameworks = arrayToHtmlArticleList(profile.frameworks, 'Frameworks');
    const databases = arrayToHtmlArticleList(
      profile.databases,
      'Bases de Datos',
    );
    const libraries = arrayToHtmlArticleList(profile.libraries, 'LibrerÃ­as');
    const patterns = arrayToHtmlArticleList(profile.patterns, 'Patrones');
    const tools = arrayToHtmlArticleList(profile.tools, 'Herramientas');

    templateHtml = templateHtml
      // user data
      .replace('{{name}}', name)
      .replace('{{surname}}', titleCase(surname))
      .replace('{{biography}}', titleCase(biography))
      .replace('{{tools}}', tools)
      .replace('{{linkedIn}}', linkedIn)
      .replace('{{github}}', github)
      .replace('{{portfolio}}', portfolio)

      // profile data
      .replace('{{jobTitle}}', jobTitle)
      .replace('{{languages}}', languages)
      .replace('{{frameworks}}', frameworks)
      .replace('{{databases}}', databases)
      .replace('{{libraries}}', libraries)
      .replace('{{patterns}}', patterns);

    pdf.create(templateHtml).toStream((error, stream) => {
      if (error) {
        res.status(500).json({
          statusCode: 500,
          message: 'An error as ocurred while being generating a PDF',
          error,
        });
      }
      res.setHeader('Content-Type', 'application/pdf');
      stream.pipe(res);
    });
  }
}
