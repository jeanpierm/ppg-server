import {
  BadRequestException,
  ForbiddenException,
  Injectable,
  Logger,
} from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import * as fs from 'fs/promises';
import * as hbs from 'handlebars';
import { FilterQuery, Model } from 'mongoose';
import * as path from 'path';
import * as puppeteer from 'puppeteer';
import { DownloadPreferencesService } from 'src/download-preferences/download-preferences.service';
import { EntityStatus } from 'src/shared/enums/status.enum';
import { UserDocument } from 'src/users/schemas/user.schema';
import { PaginatedResponseDto } from '../shared/dto/paginated-response.dto';
import { PaginationParams } from '../shared/dto/pagination-params.dto';
import { stringToDate } from '../shared/util';
import { TechnologiesService } from '../technologies/technologies.service';
import { ProfessionalProfileGenerator } from './algorithm/main';
import { GetProfessionalProfilesQuery } from './dto/get-professional-profiles-query.dto';
import { TechType } from './enums/tech-type.enum';
import {
  ProfessionalProfile,
  ProfessionalProfileDocument,
} from './schemas/professional-profile.schema';

@Injectable()
export class ProfessionalProfilesService {
  private readonly logger = new Logger(ProfessionalProfilesService.name);

  constructor(
    @InjectModel(ProfessionalProfile.name)
    private readonly proProfileModel: Model<ProfessionalProfileDocument>,
    private readonly generateProfessionalProfile: ProfessionalProfileGenerator,
    private readonly technologiesService: TechnologiesService,
    private readonly downloadPreferencesService: DownloadPreferencesService,
  ) {}

  /**
   * Genera un perfil profesional utilizando un algoritmo que hace Web Scraping.
   * El perfil generado se persiste en la base de datos.
   * @param user - current user
   * @param jobTitle
   * @param location
   */
  async generateProfile(
    user: UserDocument,
    jobTitle: string,
    location: string,
  ): Promise<ProfessionalProfile> {
    const generatedProfile = await this.generateProfessionalProfile.generate(
      user,
      jobTitle,
      location,
    );
    const createdProfile = await this.proProfileModel.create(generatedProfile);
    this.logger.log(
      `Professional profile generated by user ${user.userId}`,
      createdProfile,
    );
    return createdProfile;
  }

  async findActiveProfilesOfUser(
    user: UserDocument,
    getQuery?: GetProfessionalProfilesQuery & PaginationParams,
  ): Promise<PaginatedResponseDto<ProfessionalProfile>> {
    const filterQuery: FilterQuery<ProfessionalProfileDocument> = {
      owner: user._id,
      status: EntityStatus.Active,
    };
    const { initDate, endDate, jobTitle, location, page, size } =
      getQuery || {};
    if (initDate || endDate) filterQuery.createdAt = {};
    if (initDate) filterQuery.createdAt['$gte'] = stringToDate(initDate);
    if (endDate) filterQuery.createdAt['$lt'] = stringToDate(endDate);
    if (jobTitle)
      filterQuery.jobTitle = {
        $regex: new RegExp(jobTitle.trim().replace('.', '')),
        $options: 'i',
      };
    if (location)
      filterQuery.location = {
        $regex: new RegExp(location.trim().replace('.', '')),
        $options: 'i',
      };

    const profiles = await this.proProfileModel
      .find(filterQuery)
      .sort({ createdAt: -1 })
      .skip((page - 1) * size)
      .limit(size)
      .lean();
    const totalItems = await this.proProfileModel.count(filterQuery);
    const totalPages = Math.ceil(totalItems / size);

    this.logger.log(`Professional profiles obtained by user ${user.userId}`);

    return {
      totalItems,
      currentPage: page,
      pageSize: size,
      data: profiles,
      totalPages,
    };
  }

  async findActiveProfileOfUserById(
    ppId: string,
    user: UserDocument,
  ): Promise<ProfessionalProfile> {
    const profile = await this.proProfileModel
      .findOne({ ppId, status: EntityStatus.Active })
      .populate('jobsAnalyzed')
      .lean();
    if (user._id.equals(profile.owner)) {
      return profile;
    }
    throw new ForbiddenException(
      'This profile is not generated by the user who requested it',
    );
  }

  async removeProfileOfUser(user: UserDocument, ppId: string): Promise<void> {
    const profile = await this.proProfileModel.findOne({
      ppId,
      status: EntityStatus.Active,
    });
    if (user._id.equals(profile.owner)) {
      profile.status = EntityStatus.Inactive;
      await profile.save();
      this.logger.log(`Professional profile deleted by user ${user.userId}`);
      return;
    }
    throw new ForbiddenException(
      'This profile is not generated by the user who requested it',
    );
  }

  async getRandomProfile(): Promise<ProfessionalProfile> {
    const profilesCount = await this.proProfileModel.count().exec();
    const random = Math.floor(Math.random() * profilesCount);
    const profile = await this.proProfileModel.findOne().skip(random).exec();
    this.logger.log(`Random professional profile obtained`);
    return profile;
  }

  async getTechnologyCount(profiles: ProfessionalProfile[], type: TechType) {
    const technologies = await this.technologiesService.findByType(type);
    const dictionary: Record<string, number> = {};

    for (const { name } of technologies) {
      switch (type) {
        case TechType.Language:
          dictionary[name] = profiles.filter((profile) =>
            profile.languages.includes(name),
          ).length;
          break;
        case TechType.Database:
          dictionary[name] = profiles.filter((profile) =>
            profile.databases.includes(name),
          ).length;
          break;
        case TechType.Framework:
          dictionary[name] = profiles.filter((profile) =>
            profile.frameworks.includes(name),
          ).length;
          break;
        case TechType.Library:
          dictionary[name] = profiles.filter((profile) =>
            profile.libraries.includes(name),
          ).length;
          break;
        case TechType.Paradigm:
          dictionary[name] = profiles.filter((profile) =>
            profile.paradigms.includes(name),
          ).length;
          break;
        case TechType.Pattern:
          dictionary[name] = profiles.filter((profile) =>
            profile.patterns.includes(name),
          ).length;
          break;
        case TechType.Tool:
          dictionary[name] = profiles.filter((profile) =>
            profile.tools.includes(name),
          ).length;
          break;
      }
    }

    return dictionary;
  }

  async getEnglishCount(profiles: ProfessionalProfile[]) {
    const englishCount = { Yes: 0, No: 0 };

    profiles.forEach((profile) => {
      if (profile.requireEnglish) {
        englishCount.Yes++;
      } else {
        englishCount.No++;
      }
    });

    return englishCount;
  }

  async resume(user: UserDocument, ppId: string) {
    const profile = await this.proProfileModel
      .findOne({ user: user._id, ppId })
      .populate('owner')
      .lean();
    const preferences =
      await this.downloadPreferencesService.getDownloadPreferences(user);
    if (!profile) throw new BadRequestException();

    const html = await compile('resume', { preferences, profile });

    //helper para guardarlo en html, por si se desea revisar como se ve el html
    await fs.writeFile(
      path.join(process.cwd(), 'templates', `resume-test.html`),
      html,
    );

    const browser = await puppeteer.launch({
      headless: true,
    });
    const page = await browser.newPage();
    await page.setContent(html, {
      waitUntil: ['domcontentloaded', 'networkidle0'],
    });
    const pdfBuffer = await page.pdf({
      format: 'A4',
      printBackground: true,
    });
    await browser.close();

    return pdfBuffer;
  }
}

async function compile(templateName: string, data: Record<string, any>) {
  const filePath = path.join(process.cwd(), 'templates', `${templateName}.hbs`);
  const html = await fs.readFile(filePath, 'utf8');
  return hbs.compile(html)(data);
}

hbs.registerHelper('join', function (array: Array<string>) {
  return array.join();
});
