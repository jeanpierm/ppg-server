import {
  BadRequestException,
  ForbiddenException,
  Injectable,
  Logger,
} from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';

import { ConfigService } from '@nestjs/config';
import { FilterQuery, Model } from 'mongoose';
import * as puppeteer from 'puppeteer';
import { DownloadPreferencesService } from 'src/download-preferences/download-preferences.service';
import { EntityStatus } from 'src/shared/enums/status.enum';
import { UserDocument } from 'src/users/schemas/user.schema';
import { PuppeteerConfig } from '../../config/puppeteer.config';
import { TemplatesService } from '../../core/services/templates.service';
import { PaginatedResponseDto } from '../../shared/dto/paginated-response.dto';
import { PaginationParams } from '../../shared/dto/pagination-params.dto';
import { removeDuplicateObjects, stringToDate } from '../../shared/util';
import { TechType } from '../../tech-types/schemas/tech-type.schema';
import { Technology } from '../../technologies/schemas/technology.schema';
import { TechnologiesService } from '../../technologies/technologies.service';
import { GetProfessionalProfilesQuery } from '../dto/get-professional-profiles-query.dto';
import { TechnologyItem } from '../interfaces/technology-item.interface';
import {
  ProfessionalProfile,
  ProfessionalProfileDocument,
} from '../schemas/professional-profile.schema';
import { ProfessionalProfileGeneratorService } from './professional-profile-generator.service';

@Injectable()
export class ProfessionalProfilesService {
  private readonly logger = new Logger(ProfessionalProfilesService.name);
  private readonly puppeteerConfig =
    this.configService.get<PuppeteerConfig>('puppeteer');

  constructor(
    @InjectModel(ProfessionalProfile.name)
    private readonly proProfileModel: Model<ProfessionalProfileDocument>,
    private readonly generateProfessionalProfile: ProfessionalProfileGeneratorService,
    private readonly technologiesService: TechnologiesService,
    private readonly downloadPreferencesService: DownloadPreferencesService,
    private readonly templatesService: TemplatesService,
    private readonly configService: ConfigService,
  ) {}

  /**
   * Genera un perfil profesional utilizando un algoritmo que hace Web Scraping.
   * El perfil generado se persiste en la base de datos.
   * @param user - current user
   * @param jobTitle
   * @param location
   */
  async generateProfile(
    user: UserDocument,
    jobTitle: string,
    location: string,
  ): Promise<ProfessionalProfile> {
    const generatedProfile = await this.generateProfessionalProfile.generate(
      user,
      jobTitle,
      location,
    );
    const createdProfile = await (
      await this.proProfileModel.create({
        jobTitle: generatedProfile.jobTitle,
        location: generatedProfile.location,
        technologies: generatedProfile.technologiesIds,
        requireEnglish: generatedProfile.requireEnglish,
        owner: generatedProfile.ownerId,
        jobsAnalyzed: generatedProfile.jobsAnalyzedIds,
      })
    ).populate([
      {
        path: 'technologies',
        populate: [{ path: 'type' }],
      },
      { path: 'jobsAnalyzed' },
    ]);
    this.logger.log(`Professional profile generated by user ${user.userId}`);
    return createdProfile;
  }

  async findActiveProfilesOfUser(
    user: UserDocument,
    getQuery?: GetProfessionalProfilesQuery & PaginationParams,
  ): Promise<PaginatedResponseDto<ProfessionalProfile>> {
    const filterQuery: FilterQuery<ProfessionalProfileDocument> = {
      owner: user._id,
      status: EntityStatus.Active,
    };
    const { initDate, endDate, jobTitle, location, page, size } =
      getQuery || {};
    if (initDate || endDate) filterQuery.createdAt = {};
    if (initDate) filterQuery.createdAt['$gte'] = stringToDate(initDate);
    if (endDate) filterQuery.createdAt['$lt'] = stringToDate(endDate);
    if (jobTitle)
      filterQuery.jobTitle = {
        $regex: new RegExp(jobTitle.trim().replace('.', '')),
        $options: 'i',
      };
    if (location)
      filterQuery.location = {
        $regex: new RegExp(location.trim().replace('.', '')),
        $options: 'i',
      };

    const profiles = await this.proProfileModel
      .find(filterQuery)
      .populate([
        {
          path: 'technologies',
          populate: [{ path: 'type' }],
        },
        { path: 'jobsAnalyzed' },
      ])
      .sort({ createdAt: -1 })
      .skip((page - 1) * size)
      .limit(size)
      .lean();
    const totalItems = await this.proProfileModel.count(filterQuery);
    const totalPages = Math.ceil(totalItems / size);

    this.logger.log(`Professional profiles obtained by user ${user.userId}`);

    return {
      totalItems,
      currentPage: page,
      pageSize: size,
      data: profiles,
      totalPages,
    };
  }

  async findActiveProfileOfUserById(
    ppId: string,
    user: UserDocument,
  ): Promise<ProfessionalProfile> {
    const profile = await this.proProfileModel
      .findOne({ ppId, status: EntityStatus.Active })
      .populate([
        {
          path: 'technologies',
          populate: [{ path: 'type' }],
        },
        { path: 'jobsAnalyzed' },
      ])
      .lean();
    if (user._id.equals(profile.owner)) {
      return profile;
    }
    throw new ForbiddenException(
      'This profile is not generated by the user who requested it',
    );
  }

  async removeProfileOfUser(user: UserDocument, ppId: string): Promise<void> {
    const profile = await this.proProfileModel.findOne({
      ppId,
      status: EntityStatus.Active,
    });
    if (user._id.equals(profile.owner)) {
      profile.status = EntityStatus.Inactive;
      await profile.save();
      this.logger.log(`Professional profile deleted by user ${user.userId}`);
      return;
    }
    throw new ForbiddenException(
      'This profile is not generated by the user who requested it',
    );
  }

  async getRandomProfile(): Promise<ProfessionalProfile> {
    const profilesCount = await this.proProfileModel.count();
    const random = Math.floor(Math.random() * profilesCount);
    const profile = await this.proProfileModel
      .findOne()
      .skip(random)
      .populate([
        {
          path: 'technologies',
          populate: [{ path: 'type' }],
        },
        { path: 'jobsAnalyzed' },
      ]);
    this.logger.log(`Random professional profile obtained`);
    return profile;
  }

  async getTechnologyCount(
    profiles: ProfessionalProfile[],
    type: string,
  ): Promise<Record<string, number>> {
    const technologies = await this.technologiesService.findByType(type);
    const dictionary: Record<string, number> = {};

    for (const { name } of technologies) {
      dictionary[name] = profiles.filter((profile) =>
        profile.technologies.some((technology) => technology.name === name),
      ).length;
    }

    return dictionary;
  }

  async getEnglishCount(profiles: ProfessionalProfile[]) {
    const englishCount = { Yes: 0, No: 0 };

    profiles.forEach((profile) => {
      if (profile.requireEnglish) {
        englishCount.Yes++;
      } else {
        englishCount.No++;
      }
    });

    return englishCount;
  }

  async resume(user: UserDocument, ppId: string) {
    const profile = await this.proProfileModel
      .findOne({ user: user._id, ppId })
      .populate([{ path: 'technologies', populate: [{ path: 'type' }] }])
      .lean();

    if (!profile) throw new BadRequestException();

    const templateName = 'resume';
    const preferences =
      await this.downloadPreferencesService.getDownloadPreferences(user);
    const { technologies, jobTitle } = profile;
    const technologyItems: TechnologyItem[] = [];
    const rawTechTypes = technologies.map((technology) => technology.type);
    const techTypes = removeDuplicateObjects(rawTechTypes) as TechType[];

    techTypes.forEach((type) => {
      const technologyNames = this.getTechnologyNamesByType(
        technologies,
        type.name,
      );
      if (technologyNames.length) {
        technologyItems.push({ label: type.label, technologyNames });
      }
    });

    const html = await this.templatesService.compile(templateName, {
      preferences,
      user,
      jobTitle,
      technologyItems,
    });
    const pdfBuffer = await this.convertHTMLToPDF(html);

    return pdfBuffer;
  }

  private getTechnologyNamesByType(
    technologies: Technology[],
    typeName: string,
  ): string[] {
    return technologies
      .filter(({ type }) => type.name === typeName)
      .map(({ name }) => name);
  }

  private async convertHTMLToPDF(html: string) {
    const browser = await puppeteer.launch();
    const page = await browser.newPage();
    await page.setContent(html, {
      waitUntil: ['domcontentloaded', 'networkidle0'],
    });
    const pdfBuffer = await page.pdf({
      format: 'A4',
      printBackground: true,
    });
    await browser.close();

    return pdfBuffer;
  }
}
